% Template for PLoS
% Version 3.5 March 2018
%
% % % % % % % % % % % % % % % % % % % % % %
%
% -- IMPORTANT NOTE
%
% This template contains comments intended
% to minimize problems and delays during our production
% process. Please follow the template instructions
% whenever possible.
%
% % % % % % % % % % % % % % % % % % % % % % %
%
% Once your paper is accepted for publication,
% PLEASE REMOVE ALL TRACKED CHANGES in this file
% and leave only the final text of your manuscript.
% PLOS recommends the use of latexdiff to track changes during review, as this will help to maintain a clean tex file.
% Visit https://www.ctan.org/pkg/latexdiff?lang=en for info or contact us at latex@plos.org.
%
%
% There are no restrictions on package use within the LaTeX files except that
% no packages listed in the template may be deleted.
%
% Please do not include colors or graphics in the text.
%
% The manuscript LaTeX source should be contained within a single file (do not use \input, \externaldocument, or similar commands).
%
% % % % % % % % % % % % % % % % % % % % % % %
%
% -- FIGURES AND TABLES
%
% Please include tables/figure captions directly after the paragraph where they are first cited in the text.
%
% DO NOT INCLUDE GRAPHICS IN YOUR MANUSCRIPT
% - Figures should be uploaded separately from your manuscript file.
% - Figures generated using LaTeX should be extracted and removed from the PDF before submission.
% - Figures containing multiple panels/subfigures must be combined into one image file before submission.
% For figure citations, please use "Fig" instead of "Figure".
% See http://journals.plos.org/plosone/s/figures for PLOS figure guidelines.
%
% Tables should be cell-based and may not contain:
% - spacing/line breaks within cells to alter layout or alignment
% - do not nest tabular environments (no tabular environments within tabular environments)
% - no graphics or colored text (cell background color/shading OK)
% See http://journals.plos.org/plosone/s/tables for table guidelines.
%
% For tables that exceed the width of the text column, use the adjustwidth environment as illustrated in the example table in text below.
%
% % % % % % % % % % % % % % % % % % % % % % % %
%
% -- EQUATIONS, MATH SYMBOLS, SUBSCRIPTS, AND SUPERSCRIPTS
%
% IMPORTANT
% Below are a few tips to help format your equations and other special characters according to our specifications. For more tips to help reduce the possibility of formatting errors during conversion, please see our LaTeX guidelines at http://journals.plos.org/plosone/s/latex
%
% For inline equations, please be sure to include all portions of an equation in the math environment.  For example, x$^2$ is incorrect; this should be formatted as $x^2$ (or $\mathrm{x}^2$ if the romanized font is desired).
%
% Do not include text that is not math in the math environment. For example, CO2 should be written as CO\textsubscript{2} instead of CO$_2$.
%
% Please add line breaks to long display equations when possible in order to fit size of the column.
%
% For inline equations, please do not include punctuation (commas, etc) within the math environment unless this is part of the equation.
%
% When adding superscript or subscripts outside of brackets/braces, please group using {}.  For example, change "[U(D,E,\gamma)]^2" to "{[U(D,E,\gamma)]}^2".
%
% Do not use \cal for caligraphic font.  Instead, use \mathcal{}
%
% % % % % % % % % % % % % % % % % % % % % % % %
%
% Please contact latex@plos.org with any questions.
%
% % % % % % % % % % % % % % % % % % % % % % % %

\documentclass[10pt,letterpaper]{article}
\usepackage[top=0.85in,left=1.625in,right=1.625in,footskip=0.75in]{geometry}

% amsmath and amssymb packages, useful for mathematical formulas and symbols
\usepackage{amsmath,amssymb,mathtools}

% Use adjustwidth environment to exceed column width (see example table in text)
\usepackage{changepage}

% Use Unicode characters when possible
\usepackage[utf8x]{inputenc}

% textcomp package and marvosym package for additional characters
\usepackage{textcomp,marvosym}

% cite package, to clean up citations in the main text. Do not remove.
\usepackage{cite}

% Use nameref to cite supporting information files (see Supporting Information section for more info)
% TODO: hidelinks.
\usepackage{nameref}
\usepackage[hidelinks]{hyperref}

% line numbers
\usepackage[right]{lineno}

% ligatures disabled
\usepackage{microtype}
\DisableLigatures[f]{encoding = *, family = * }

% color can be used to apply background shading to table cells only
\usepackage[table]{xcolor}

% array package and thick rules for tables
\usepackage{array}

% create "+" rule type for thick vertical lines
\newcolumntype{+}{!{\vrule width 2pt}}

% create \thickcline for thick horizontal lines of variable length
\newlength\savedwidth
\newcommand\thickcline[1]{%
  \noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt}%
  \cline{#1}%
  \noalign{\vskip\arrayrulewidth}%
  \noalign{\global\arrayrulewidth\savedwidth}%
}

% \thickhline command for thick horizontal lines that span the table
\newcommand\thickhline{\noalign{\global\savedwidth\arrayrulewidth\global\arrayrulewidth 2pt}%
\hline
\noalign{\global\arrayrulewidth\savedwidth}}


% Remove comment for double spacing
%\usepackage{setspace}
%\doublespacing

% Text layout
%\raggedright
\setlength{\parindent}{0.5cm}
\textwidth 5.25in
\textheight 8.75in

% Bold the 'Figure #' in the caption and separate it from the title/caption with a period
% Captions will be left justified
\usepackage[aboveskip=1pt,labelfont=bf,labelsep=period,justification=raggedright,singlelinecheck=off]{caption}
\renewcommand{\figurename}{Figure}

% Use the PLoS provided BiBTeX style
\bibliographystyle{plos2015}

% Remove brackets from numbering in List of References
\makeatletter
\renewcommand{\@biblabel}[1]{\quad#1.}
\makeatother



% Header and Footer with logo
\usepackage{lastpage,fancyhdr,graphicx}
\usepackage{epstopdf}
%\pagestyle{myheadings}
\pagestyle{fancy}
\fancyhf{}
%\setlength{\headheight}{27.023pt}
%\lhead{\includegraphics[width=2.0in]{PLOS-submission.eps}}
\rfoot{\thepage/\pageref{LastPage}}
\renewcommand{\headrulewidth}{0pt}
\renewcommand{\footrule}{\hrule height 2pt \vspace{2mm}}
% \fancyheadoffset[L]{2.25in}
% \fancyfootoffset[L]{2.25in}
\lfoot{\today}

%% Include all macros below

\newcommand{\ocp}{
\begin{adjustwidth}{-1.125in}{-1.125in} % Comment out/remove adjustwidth environment if table fits in text column.
% \mathrlap causes the contents to not take up horizontal space, allowing
% overlapping columns.
\begin{align}
    \begin{aligned}
        \mbox{minimize}
         \quad & \sum_j w_{j} J_{j}(t_0, t_f, y_0, y_f, x_{0}, \mathrlap{x_{f}, \lambda_0, \lambda_f, p, S_{c,j})} && \textrm{costs} \\
        & \quad\quad S_{c,j} = \int_{t_0}^{t_f} s_{c,j}(t, y, x, \lambda, p)\,dt  \\
        \mbox{subject to}
         \quad & \dot{q} = u \\
         & M(q, p)\dot{u} + G(q, p)^T \lambda = f_{\mathrm{app}}(t, y, x, p) - f_{\mathrm{inertial}}(q, u, p)  && \textrm{multibody dynamics} \\
         & \dot{z}_\textrm{ex}(t) = f_{\dot{z},\textrm{ex}}(t, y, x, \lambda, p) && \textrm{auxiliary dynamics, explicit} \\
         & 0 = f_{\dot{z},\textrm{im}}(t, y, \dot{z}_{\textrm{im}}, x, \lambda, p) &&  \textrm{auxiliary dynamics, implicit}\\
         & 0 = \phi(q, p) && \textrm{kinematic constraints} \\
         & V_{L,k} \leq V_k(t_0, t_f, y_0, y_f, x_{0}, x_{f}, \lambda_0, \lambda_f, p, S_{b,k}) \leq V_{U,k} && \textrm{boundary constraints} \\
         & \quad\quad S_{b,k} = \int_{t_0}^{t_f} s_{b,k}(t, y, x, \lambda, p)\,dt \quad k = 1, \ldots, K\\
         & g_{L} \leq g(t, y, x, \lambda, p) \leq g_{U} && \textrm{path constraints} \\
         & y_{0,L} \leq y_0 \leq y_{0,U} \quad\quad y_{f,L} \leq y_f \leq y_{f,U} && \textrm{initial and final states} \\
         & x_{0,L} \leq x_0 \leq x_{0,U} \quad\quad x_{f,L} \leq x_f \leq x_{f,U} && \textrm{initial and final controls} \\
         \mbox{with respect to} \quad
         & t_0 \in [t_{0,L}, t_{0,U}] && \textrm{initial time} \\
         & t_f \in [t_{f,L}, t_{f,U}] && \textrm{final time} \\
         & y(t) = (q(t), u(t), z(t)) \in [y_{L}, y_{U}] && \textrm{states} \\
         & x(t) \in [x_{L}, x_{U}] && \textrm{controls} \\
         & \lambda(t) && \textrm{Lagrange multipliers} \\
         & p \in [p_{L}, p_{U}] && \textrm{time-invariant parameters}
    \end{aligned}
\end{align}
\end{adjustwidth}
}

\newcommand{\prescribed}{
\begin{adjustwidth}{-1.125in}{-1.125in} % Comment out/remove adjustwidth environment if table fits in text column.
\begin{align}
    \begin{aligned}
        \mbox{minimize} \quad & \mathrlap{\sum_j w_j J_{j}(t_0, t_f, \hat{q}_0, \hat{q}_f, \hat{u}_0, \hat{u}_f, z_0, z_f, x_{0}, x_{f}, \lambda_0, \lambda_f, p, S_{c,j})} &&&\hspace{6em}& \textrm{costs} \\
        & \quad\quad \mathrlap{S_{c,j} = \int_{t_0}^{t_f} s_{c,j}(t, \hat{q}, \hat{u}, z, x, \lambda, p)~dt} \\
        \mbox{subject to} \quad &
         M(\hat{q}, p)\hat{\dot{u}} + \mathrlap{G(\hat{q}, p)^T \lambda = f_{\textrm{app}}(t, \hat{q}, \hat{u}, z, x, p) - f_{\textrm{inertial}}(\hat{q}, \hat{u}, p)} &&&& \textrm{multibody dynamics} \\
        & \mathrlap{\dot{z}_{\textrm{ex}}(t) = f_{\dot{z},\textrm{ex}}(t, \hat{q}, \hat{u}, z, x, \lambda, p)} &&&& \textrm{auxiliary dynamics, explicit} \\
        & \mathrlap{0 = f_{\dot{z},\textrm{im}}(t, \hat{q}, \hat{u}, z, \dot{z}_\textrm{im}, x, \lambda, p)} &&&& \textrm{auxiliary dynamics, implicit}\\
        & V_{L,k} \leq V_k(t_0, t_f, \hat{q}_0, \mathrlap{\hat{q}_f, \hat{u}_0, \hat{u}_f, z_0, z_f, x_{0}, x_{f}, \lambda_0, \lambda_f, p, S_{b,k}) \leq V_{U,k}}  &&&& \textrm{boundary constraints} \\
        & \quad\quad \mathrlap{S_{b,k} = \int_{t_0}^{t_f} s_{b,k}(t, \hat{q}, \hat{u}, z, x, \lambda, p)~dt \quad k = 1, \ldots, K} \\
        & \mathrlap{g_{L} \leq g(t, \hat{q}, \hat{u}, z, x, \lambda, p) \leq g_{U}} &&&& \textrm{path constraints} \\
        & z_{0,L} \leq z_0 \leq z_{0,U} && z_{f,L} \leq z_f \leq z_{f,U} && \textrm{initial and final states} \\
        & x_{0,L} \leq x_0 \leq x_{0,U} && x_{f,L} \leq x_f \leq x_{f,U} && \textrm{initial and final controls} \\
        \mbox{with respect to} \quad
        & t_0 \in [t_{0,L}, t_{0,U}] && \textrm{initial time} \\
        & t_f \in [t_{f,L}, t_{f,U}] && \textrm{final time} \\
        & z(t) \in [z_{L}, z_{U}] && \textrm{auxiliary states} \\
        & x(t) \in [x_{L}, x_{U}] && \textrm{controls} \\
        & \lambda(t) && \textrm{Lagrange multipliers} \\
        & p \in [p_{L}, p_{U}]. && \textrm{time-invariant parameters}
    \end{aligned}
\end{align}
\end{adjustwidth}
}

\newcommand{\traptau}{
\begin{equation}
    \begin{gathered}
        0 = \tau_0 < \tau_1 < \tau_2 < \ldots < \tau_i < \ldots < \tau_{n - 1} < \tau_n = 1, \\
        \begin{aligned}
        t_i &= (t_f - t_0) \tau_i + t_0, \\
        h_i &= (t_f - t_0)(\tau_i - \tau_{i-1}).
        \end{aligned}
    \end{gathered}
\end{equation}
}

\newcommand{\trapfunc}{
\begin{equation}
    \textrm{trap}_i(F(\eta, p)) = \frac{1}{2} h_i (F(\eta_{i-1}, p) + F(\eta_i, p)),
\end{equation}
}

\newcommand{\explicitmultibody}{
\begin{equation}
    f_{\dot{u}}(t, y, x, \lambda, p) =
    M(q, p)^{-1}\big[(f_{\textrm{app}}(t, y, x, p) - f_{\textrm{inertial}}(q, u, p) - G(q, p)^T \lambda\big].
\end{equation}
}

\newcommand{\trapnlp}{
\begin{align}
    \begin{aligned}
        \mbox{minimize} \quad
         & \sum_j w_j J_{j}(t_0, t_f, \mathrlap{y_0, y_n, x_{0}, x_{n}, \lambda_0, \lambda_n, p, S_{c,j})
          + w_{\lambda} \sum_{i=1}^{n} \textrm{trap}_i(\|\lambda\|_2^2)}  \\
         & \quad\quad \mathrlap{S_{c,j} = \sum_{i=1}^{n} \textrm{trap}_i(s_{c,j}(t, y, x, \lambda, p))} \\
        \mbox{subject to} \quad
         & \mathrlap{q_i = q_{i-1} + \textrm{trap}_i(u)} &&&& i = 1, \ldots, n \\
         & \mathrlap{u_i = u_{i-1} + \textrm{trap}_i(f_{\dot{u}}(t, y, x, \lambda, p))}  &&&& i = 1, \ldots, n \\
         & \mathrlap{z_{\textrm{ex},i} = z_{\textrm{ex},i-1} + \textrm{trap}_i(f_{\dot{z},\textrm{ex}}(t, y, x, \lambda, p))} &&&& i = 1, \ldots, n \\
         & \mathrlap{z_{\textrm{im},i} = z_{\textrm{im},i-1} + \textrm{trap}_i(\zeta)} &&&& i = 1, \ldots, n \\
         & \mathrlap{0 = f_{\dot{z},\textrm{im}}(t_i, y_i, \zeta_i, x_i, \lambda_i, p)} &&&& i = 0, \ldots, n \\
         & 0 = \phi(q_i, p)  &&&& i = 0, \ldots, n\\
         & V_{L,k} \leq V_k(t_0, t_f, y_0, \mathrlap{y_f, x_{0}, x_{f}, \lambda_0, \lambda_f, p, S_{b,k}) \leq V_{U,k}} \\
         & \quad\quad \mathrlap{S_{b,k} = \sum_{i=1}^{n} \textrm{trap}_i(s_{b,k}(t, y, x, \lambda, p))} &&&& k = 1, \ldots, K \\
         & \mathrlap{g_{L} \leq g(t_i, y_i, x_{i}, \lambda_i, p) \leq g_{U}}  &&&& i = 0, \ldots, n\\
         \mbox{with respect to} \quad
         & t_0 \in [t_{0,L}, t_{0,U}] && t_n \in [t_{f,L}, t_{f,U}] \\
         & y_0 \in [y_{0,L}, y_{0,U}] && y_n \in [y_{f,L}, y_{f,U}] \\
         & y_i \in [y_{L}, y_{U}] &&&& i = 1, \ldots, n - 1\\
         & \zeta_i \in [\zeta_{L}, \zeta_{U}] &&&& i = 0, \ldots, n \\
         & x_0 \in [x_{0,L}, x_{0,U}] && x_n \in [x_{f,L}, x_{f,U}] \\
         & x_i \in [x_{L}, x_{U}] &&&& i = 1, \ldots, n - 1\\
         & \lambda_i \in [\lambda_L, \lambda_U] &&&& i = 0, \ldots, n \\
         & p \in [p_{L}, p_{U}].
    \end{aligned}
\end{align}
}

\newcommand{\trapimplicit}{
\begin{align}
    \begin{aligned}
    \mbox{subject to} \quad
         & u_i = u_{i-1} + \textrm{trap}_i(\upsilon)  && i = 1, \ldots, n \\
         & M(q_i, p)\upsilon_i + G(q_i, p)^T \lambda_i =
          f_{\textrm{app},i} - f_{\textrm{inertial},i} && i = 0, \ldots, n \\
    \mbox{with respect to} \quad
         & \upsilon_i \in [-\upsilon_{B}, \upsilon_{B}] && i = 0, \ldots, n.\\
    \end{aligned}
\end{align}
}

\newcommand{\hermitesimpsontau}{
\begin{equation}
    \begin{gathered}
        0 = \tau_0 < \tau_1 < \tau_2 < \ldots < \tau_i < \ldots < \tau_{n - 1} < \tau_n = 1, \\
        \begin{aligned}
        \bar{\tau}_i &= 0.5 (\tau_{i-1} + \tau_i), \\
        t_i &= (t_f - t_0) \tau_i + t_0, \\
        \bar{t}_i &= (t_f - t_0) \bar{\tau}_i + t_0, \\
        h_i &= (t_f - t_0)(\tau_i - \tau_{i-1}),
        \end{aligned}
    \end{gathered}
\end{equation}
}

\newcommand{\hermitesimpsonfuncs}{
\begin{align}
    \textrm{hermite}_i(\eta, F(\eta, p)) &= \frac{1}{2} (\eta_{i-1} + \eta_i) + \frac{h_i}{8} (F(\eta_{i-1}, p) - F(\eta_i, p)), \\
    \textrm{simpson}_i(F(\eta, p)) &= \frac{h_i}{6} (F(\eta_{i-1}, p) + 4 F(\bar{\eta}_i, p) + F(\eta_i, p)),
\end{align}
}

\newcommand{\hermitesimpsonnlp}{
\begin{align}
    \begin{aligned}
        \mbox{minimize} \quad
         & \sum_j w_j J_{c,j}(t_0, t_f, \mathrlap{y_0, y_n, x_{0}, x_{n}, \lambda_0, \lambda_n, p, S_{c,j})
         + w_{\lambda} \sum_{i=1}^{n} \textrm{simpson}_i(\|\lambda\|_2^2)}  \\
         & \quad\quad \mathrlap{S_{c,j} = \sum_{i=1}^{n} \textrm{simpson}_i(s_{c,j}(t, y, x, \lambda, p))} \\
        \mbox{subject to} \quad
         & \mathrlap{\bar{q}_i = \textrm{hermite}_i(q, u) + G(\bar{q}_i, p)^T \bar{\gamma}_i} &&&& i = 1, \ldots, n \\
         & \mathrlap{q_i = q_{i-1} + \textrm{simpson}_i(u)} &&&& i = 1, \ldots, n \\
         & \mathrlap{\bar{u}_i = \textrm{hermite}_i(u, f_{\dot{u}}(t, y, x, \lambda, p))} &&&& i = 1, \ldots, n \\
         & \mathrlap{u_i = u_{i-1} + \textrm{simpson}_i(f_{\dot{u}}(t, y, x, \lambda, p))}  &&&& i = 1, \ldots, n \\
         & \mathrlap{\bar{z}_{\textrm{ex},i} = \textrm{hermite}_i(z_{\textrm{ex}}, f_{\dot{z},\textrm{ex}}(t, y, x, \lambda, p))} &&&& i = 1, \ldots, n \\
         & \mathrlap{z_{\textrm{ex},i} = z_{\textrm{ex},i-1} + \textrm{simpson}_i(f_{\dot{z},\textrm{ex}}(t, y, x, \lambda, p))} &&&& i = 1, \ldots, n \\
         & \mathrlap{\bar{z}_{\textrm{im},i} = \textrm{hermite}_i(z_{\textrm{im}}, \zeta)} &&&& i = 1, \ldots, n \\
         & \mathrlap{z_{\textrm{im},i} = z_{\textrm{im},i-1} + \textrm{simpson}_i(\zeta)} &&&& i = 1, \ldots, n \\
         & \mathrlap{0 = f_{\dot{z},\textrm{im}}(t_i, y_i, \zeta_i, x_i, \lambda_i, p)} &&&& i = 0, \ldots, n \\
         & \mathrlap{\bar{x}_i = (x_{i-1} + x_i)/2} &&&& i = 1, \ldots, n \\
         & \mathrlap{0 = \phi(q_i, p) = \dot{\phi}(q_i, u_i, p) = \ddot{\phi}(t_i, y_i, x_i, \lambda_i, p)}  &&&& i = 0, \ldots, n\\
         & V_{L,k} \leq V_k(t_0, t_f, y_0, y_f, x_{0}, \mathrlap{x_{f}, \lambda_0, \lambda_f, p, S_{b,k}) \leq V_{U,k}} \\
        & \quad\quad \mathrlap{S_{b,k} = \sum_{i=1}^{n} \textrm{simpson}_i(s_{b,k}(t, y, x, \lambda, p))} &&&& k = 1, \ldots, K \\
        & \mathrlap{g_{L} \leq g(t_i, y_i, x_{i}, \lambda_i, p) \leq g_{U}}  &&&& i = 0, \ldots, n\\
         \mbox{with respect to} \quad
         & t_0 \in [t_{0,L}, t_{0,U}] && t_n \in [t_{f,L}, t_{f,U}] \\
         & y_0 \in [y_{0,L}, y_{0,U}] && y_n \in [y_{f,L}, y_{f,U}] \\
         & y_i \in [y_{L}, y_{U}] &&&& i = 1, \ldots, n - 1 \\
         & \bar{y}_i \in [y_{L}, y_{U}] &&&& i = 1, \ldots, n \\
         & \zeta_i \in [\zeta_{L}, \zeta_{U}] &&&& i = 0, \ldots, n \\
         & \bar{\zeta}_i \in [\zeta_{L}, \zeta_{U}] &&&& i = 1, \ldots, n \\
         & x_0 \in [x_{0,L}, x_{0,U}] && x_n \in [x_{f,L}, x_{f,U}] \\
         & x_i \in [x_{L}, x_{U}] &&&& i = 1, \ldots, n - 1 \\
         & \bar{x}_i \in [x_{L}, x_{U}] &&&& i = 1, \ldots, n \\
         & \lambda_i \in [\lambda_L, \lambda_U] &&&& i = 0, \ldots, n \\
         & \bar{\lambda}_i \in [\lambda_L, \lambda_U] &&&& i = 1, \ldots, n \\
         & \bar{\gamma}_i \in [\bar{\gamma}_L, \bar{\gamma}_U] &&&& i = 1, \ldots, n \\
         & p \in [p_{L}, p_{U}].
    \end{aligned}
\end{align}
}

\newcommand{\hermitesimpsonkincon}{
    \begin{align}
         0 &= \dot{\phi}(q, u, p) = G(q, p) u,\\
         0 &= \ddot{\phi}(t, y, x, \lambda, p) = G(q, p) f_{\dot{u}}(t, y, x, \lambda, p) + \dot{G}(q, p) u.
    \end{align}
}

\newcommand{\hermitesimpsonimplicit}{
\begin{align}
    \begin{aligned}
    \mbox{subject to} \quad
         & \bar{u}_i = \textrm{hermite}_i(u, \upsilon) && i = 1, \ldots, n \\
         & u_i = u_{i-1} + \textrm{simpson}_i(\upsilon)  && i = 1, \ldots, n \\
         & M(q_i, p)\upsilon_i + G(q_i, p)^T \lambda_i =
          f_{\textrm{app},i} -
            f_{\textrm{inertial},i} && i = 0, \ldots, n \\
         & M(\bar{q}_i, p)\bar{\upsilon}_i + G(\bar{q}_i, p)^T \bar{\lambda}_i =
          \bar{f}_{\textrm{app},i} -
            \bar{f}_{\textrm{inertial},i} && i = 1, \ldots, n \\
    \mbox{with respect to} \quad
         & \upsilon_i \in [-\upsilon_{B}, \upsilon_{B}] && i = 0, \ldots, n \\
         & \bar{\upsilon}_i \in [-\upsilon_{B}, \upsilon_{B}] && i = 1, \ldots, n.
    \end{aligned}
\end{align}
}

\newcommand{\analytic}{
\begin{equation}
    \begin{aligned}
        \mbox{minimize} \quad
         \mathrlap{\int_{t_0}^{t_f} \frac{1}{2}x^2~dt}  \\
         \mbox{subject to} \quad
         && \dot{q} &= u \\
         && \dot{u} &= -u + x \\
         && t_0 &= 0 & t_f &= 2 \\
         && q_0 &= 0 & q_f &= 5 \\
         && u_0 &= 0 & u_f &= 2.
    \end{aligned}
\end{equation}
}

%% END MACROS SECTION

% PREPRINT ONLY:
% TODO: load results dynamically, not hard-coded.
\usepackage[charter]{mathdesign}
\usepackage{charter}
\usepackage{mathtools}
\usepackage{matlab-prettifier}
\lstset{basicstyle=\mlttfamily}

\begin{document}
\vspace*{0.2in}

% Title must be 250 characters or less.
\begin{flushleft}
{\Large
\textbf\newline{OpenSim Moco: Musculoskeletal optimal control} % Please use "sentence case" for title and headings (capitalize only the first word in a title (or heading), the first word in a subtitle (or subheading), and any proper nouns).
}
\newline
% Insert author names, affiliations and corresponding author email (do not include titles, positions, or degrees).
\\
Christopher L. Dembia\textsuperscript{1\Yinyang*},
Nicholas A. Bianco\textsuperscript{1\Yinyang},
Antoine Falisse\textsuperscript{2},
Jennifer L. Hicks\textsuperscript{3},
Scott L. Delp\textsuperscript{1,3,4}
\\
\bigskip
\textbf{1} Department of Mechanical Engineering, Stanford University, Stanford, California, United States of America
\\
\textbf{2} Department of Movement Sciences, KU Leuven, Leuven, Belgium
\\
\textbf{3} Department of Bioengineering, Stanford University, Stanford, California, United States of America
\\
\textbf{4} Department of Orthopaedic Surgery, Stanford University, Stanford, California, United States of America
\\
\bigskip

% Insert additional author notes using the symbols described below. Insert symbol callouts after author names as necessary.
%
% Remove or comment out the author notes below if they aren't used.
%
% Primary Equal Contribution Note
\Yinyang These authors contributed equally to this work.

% Additional Equal Contribution Note
% Also use this double-dagger symbol for special authorship notes, such as senior authorship.
%\ddag These authors also contributed equally to this work.

% Current address notes
%\textcurrency Current Address: Dept/Program/Center, Institution Name, City, State, Country % change symbol to "\textcurrency a" if more than one current address note
% \textcurrency b Insert second current address
% \textcurrency c Insert third current address

% Deceased author note
%\dag Deceased

% Group/Consortium Author Note
%\textpilcrow Membership list can be found in the Acknowledgments section.

% Use the asterisk to denote corresponding authorship and provide email address in note below.
* dembia@stanford.edu

\end{flushleft}
% Please keep the abstract below 300 words
\section*{Abstract}
Musculoskeletal simulations of movement can provide insights needed to help humans regain mobility after injuries and design robots that interact with humans. Here, we introduce OpenSim Moco, a software toolkit for optimizing the motion and control of musculoskeletal models built in the OpenSim modeling and simulation package. OpenSim Moco uses the direct collocation method, which is often faster and can handle more diverse problems than other methods for musculoskeletal simulation but requires extensive technical expertise to implement. Moco frees researchers from implementing direct collocation themselves, allowing them to focus on their scientific questions. The software can handle the wide range of problems that interest biomechanists, including motion tracking, motion prediction, parameter optimization, model fitting, electromyography-driven simulation, and device design. Moco is the first musculoskeletal direct collocation tool to handle kinematic constraints, which are common in musculoskeletal models. To show Moco's abilities, we first solve for muscle activity that produces an observed walking motion while minimizing muscle excitations and knee joint loading. Then, we predict a squat-to-stand motion and optimize the stiffness of a passive assistive knee device. We designed Moco to be easy to use, customizable, and extensible, thereby accelerating the use of simulations to understand human and animal movement.


% Please keep the Author Summary between 150 and 200 words
% Use first person. PLOS ONE authors please skip this step.
% Author Summary not valid for PLOS ONE submissions.
% \section*{Author summary}

% TODO \linenumbers

% Use "Eq" instead of "Equation" for equation citations.
\section*{Introduction}


Musculoskeletal simulations have shed light on movement disorders by, for example, discovering ways to walk that reduce knee loading~\cite{Fregly:2007ac}, revealing that children with cerebral palsy exhibit simplified motor control when walking~\cite{Steele:2015}, and reproducing eye disorders that cause double vision~\cite{Priamikov:2016}. Simulations provide insights to increase safety as we push the limits of human performance, whether that is designing exercise equipment for preserving bone density in low gravity~\cite{Fregly:2015}, designing exoskeletons to reduce back injuries from heavy lifting~\cite{Manns:2016}, or assessing the effect of training programs on knee ligament injuries in soccer~\cite{Thompson:2017}. Beyond human health and performance, researchers use musculoskeletal simulations to understand how animals move, for example by studying dinosaur locomotion~\cite{sthaya:2005uk} and differences between human and chimpanzee strength~\cite{ONeill:2017}.

Simulations of movement are often categorized by whether the motion is prescribed from data or predicted by the simulation. One may prescribe the motion of a musculoskeletal model~\cite{Thelen:2003bba,Lloyd:2003} to estimate unmeasured quantities such as muscle-level energy consumption~\cite{Farris:2014du,Jackson:2017go}. Motion prediction~\cite{Geijtenbeek:2019} can establish cause-effect relationships and help design clinical interventions, such as discovering gait impairments that arise from weakness and contracture~\cite{Ong:2019} and designing prostheses for amputees~\cite{Handford:2016kd}. Existing prescribed motion methods are rapid but either not customizable (e.g., cost functions are predefined) or lack support for important model features such as muscle dynamics. Predicting a motion often requires using a model with simplified musculature, reducing the dimensionality of the control scheme, or waiting many hours or days for a solution. A third category, which lies between prescribing and predicting, is tracking a motion, where errors between experimental and simulated kinematics are minimized~\cite{Lin:2017jp}. To accelerate the application of simulations to scientific and clinical questions, researchers need unified simulation tools for solving diverse problems that span the prescribed-to-predicted spectrum and involve a variety of costs and unknown model parameters. For example, clinicians may be interested in subtle changes to an observed motion that minimize joint loading~\cite{Fregly:2007ac}, and device designers may seek optimal stiffness parameters for a passive exoskeleton to improve the speed of an observed motion, but off-the-shelf simulation tools cannot handle these problems.

Most musculoskeletal simulation problems are naturally posed as optimal control problems: we seek a system's parameters and time-varying controls that minimize a cost (e.g., energy consumption) subject to the dynamics of the system, expressed as differential-algebraic equations. An increasingly popular method for solving optimal control problems is to approximate the system's states and controls as polynomial splines and solve for the knot points that lead the spline to obey the system's dynamics~\cite{Betts:2010,Umberger:2018ec,Mombaur:2016eb,Kelly:2017}. The dynamics are enforced by requiring the time derivative of the state splines to match the derivative from the system's differential equations at specified time points. This method is called “direct collocation” because the spline derivatives are “collocated” with the exact derivatives (\cite{Hairer:1993}, page 211;~\cite{Hairer:1996}, page 498). Direct collocation produces a nonlinear program in which the system states are introduced as variables and the system's dynamics are enforced as constraints. Typical musculoskeletal models lead to optimization problems with thousands of variables, yet these problems are tractable because the constraints enforcing dynamics at a given time depend only on the variables near that time; this speeds optimization. The method can handle a wide range of objectives and optimize model parameters, and leads to nonlinear programs that can be solved by generic optimization software.

The advantages of direct collocation have led biomechanists to use the method for tracking motions~\cite{Lin:2017jp,Mehrabi:2019}, predicting motions~\cite{Ackermann:2010dd,Miller:2015fc,Porsa:2015dn,Meyer:2016gl,Lee:2016dn,KMoore:2018ea,Lin:2018ex,Lai:2018,Nguyen:2019,Falisse:2019b}, fitting muscle properties~\cite{Falisse:2016}, and optimizing design parameters~\cite{Rohani:2017}. Researchers have made key methodological advances, including efficiently handling multibody and muscle dynamics via implicit formulations~\cite{vandenBogert:2011fv,Groote:2016dq}, minimizing energy consumption~\cite{Koelewijn:2018kw,Koelewijn:2019}, and employing algorithmic differentiation to simulate complex models more rapidly compared to using finite differences~\cite{Falisse:2019a}. Along with these methodological advances, researchers have discovered that minimizing an energy-related cost produces non-physiological motions during walking~\cite{Ackermann:2010dd}, skipping is the most efficient gait on our moon~\cite{Ackermann:2012}, and unilateral amputees can improve gait symmetry with only a minor increase in effort~\cite{Koelewijn:2016bm}.

Despite its advantages, direct collocation is not easy to implement, and very few laboratories have been able to apply this powerful technique. The method requires arduous bookkeeping of variables and efficient calculation of the objective and constraint function derivatives required by gradient-based optimization algorithms. Several direct collocation solvers exist (e.g., \cite{Becerra:2010,Patterson:2014}), but current solvers require users to incorporate their musculoskeletal models manually. OpenSim is a software package used by thousands of biomechanics researchers to model musculoskeletal systems~\cite{Delp:2007ij,Seth:2018gg,Sherman:2011byc}, but OpenSim does not provide direct collocation. Several biomechanists have graciously shared their code combining OpenSim or hand-coded models with direct collocation solvers, but such code is tailored to specific models or motions, handles only unconstrained models, contains closed-source components, or is difficult to install on one's own computer. Lastly, choosing the problem formulation (e.g., expressing dynamics as explicit or implicit differential equations) and solver settings (e.g., detecting sparsity patterns automatically) that lead to fast convergence requires expertise; ideally, such expertise is embedded into the software via defaults, and users can edit their formulation or solver settings with single commands.

To improve the accessibility of advanced optimal control methods in musculoskeletal biomechanics, we introduce OpenSim Moco (``musculoskeletal optimal control''), an easy-to-use, customizable, and extensible software toolkit for solving optimal control problems with OpenSim musculoskeletal models. OpenSim frees biomechanists from implementing equations of motion on their own, and OpenSim Moco frees biomechanists from implementing direct collocation. Moco not only removes the need to set up gradient-based optimization, but also includes an interface that abstracts away the details of constructing an optimal control problem. With just a few lines of code, researchers can solve complex problems with an OpenSim model for almost any movement. Users can add custom cost terms or constraints if Moco does not provide what they need. This paper first details the design and implementation of the software. We next show that Moco can accurately estimate muscle activity for an observed walking motion and allows users to customize the cost terms that are minimized. Finally, to illustrate that Moco can rapidly predict motions and model parameters, we predict a squat-to-stand motion and optimize the stiffness of a passive assistive device.


\section*{Design and implementation}

Moco solves optimal control problems that users define using a library of cost and constraint modules, which are implemented through configurable software classes. Users describe their problem with the \textit{MocoProblem} class. To decouple the problem from the numerical methods used to solve it, we use the \textit{MocoSolver} class. (We denote names of classes in Moco and Moco's dependencies with italics.) Moco classes are available via C++, MATLAB, Python, and XML text files, with interfaces familiar to OpenSim users. We package the \textit{MocoProblem} and \textit{MocoSolver} together into a \textit{MocoStudy} (Figure 1), which can be written to and loaded from XML text files. Moco contains utilities for visualizing and plotting a study's solution, which is held by the \textit{MocoSolution} class. For certain standard biomechanics problems, Moco provides simpler interfaces that may be preferable to the flexibility of \textit{MocoStudy}.

% Place figure captions after the first paragraph in which they are cited.
\begin{figure}[!h]
%\begin{adjustwidth}{-2.25in}{0in} % Comment out/remove adjustwidth environment if table fits in text column.
\centering
    \includegraphics{../figures/MocoStudyDiagram.png}
    \caption{{\bf Overview of \textit{MocoStudy}.}
    Moco can solve custom optimal control problems using a library of cost, boundary constraint, and path constraint modules. Moco contains additional cost modules beyond what is shown here, and users can define their own custom modules.}
    \label{mocodiagram}
%\end{adjustwidth}
\end{figure}

\subsection*{Defining problems with \textit{MocoProblem}}

\textit{MocoProblem} supports a diversity of scientific questions and contains the following elements.
\begin{itemize}
\item \textbf{cost terms}: Users can minimize a weighted sum of control effort, deviation from an observed motion, joint reaction loads, the duration of a motion, and other costs by appending to the \textit{MocoProblem} an instance of the class associated with a cost module (e.g., \textit{MocoControlGoal} implements the control effort cost).
\item \textbf{multibody dynamics, muscle dynamics, and kinematic constraints}: OpenSim \textit{Models} are a standard way to describe musculoskeletal systems, and Moco uses OpenSim \textit{Models} to obtain the system's multibody dynamics, auxiliary dynamics (e.g., muscle activation dynamics and tendon compliance), and kinematic constraints. Moco handles kinematic constraints, which are commonly used to model anatomy such as the knee, shoulder, and neck~\cite{Seth:2016,Lerner:2015,Rajagopal:2016ek,Cazzola:2017}.
\item \textbf{boundary constraints}: Users can enforce average speed, symmetry, or periodicity with constraints relating initial and final states.
\item \textbf{path constraints}: Users can constrain any function of time to lie in a specified range over the motion. For example, researchers often estimate muscle activity with electromyography and Moco allows constraining simulated muscle excitations to be close to those measurements via the \textit{MocoControlBoundConstraint} class. (These path constraints are not related to OpenSim's actuator paths.)
\item \textbf{parameter optimization}: Users can optimize model properties, such as a body's mass, a muscle's optimal fiber length, or an exoskeleton's stiffness.
\item \textbf{bounds on variables}: Users can bound the values of states, controls, and initial and final time.
\end{itemize}
The modules of a \textit{MocoProblem} can be combined in diverse ways, as demonstrated by the following examples.
\begin{itemize}
\item \textbf{dynamically-constrained inverse kinematics}: minimize the error between experimental and model marker positions (marker tracking) and control effort while obeying multibody dynamics. The optimized variables are generalized coordinates, speeds, and forces.
\item \textbf{electromyography-constrained muscle force estimation}: for a prescribed experimental motion, minimize muscle excitations while obeying multibody dynamics and the difference between muscle excitations and electromyography data. The muscle excitations are the only variables in this problem.
\item \textbf{torso mass calibration}: for a prescribed experimental motion, minimize model residual forces at the pelvis while obeying multibody dynamics. The joint torques and torso mass are the variables.
\item \textbf{prediction of muscle coordination adaptations to an exoskeleton}: minimize squared muscle excitations and the error between experimental joint angles and model coordinate values (state tracking) while obeying multibody and muscle activation dynamics. The model coordinates, speeds, muscle excitations, muscle activations, and exoskeleton torques are the variables.
\end{itemize}
\textit{MocoProblem} describes the optimization problem in Eq (1). We seek the time-dependent states $y(t)$ and controls $x(t)$ that minimize a sum of costs $J_j$ with weights $w_j$. The states include generalized coordinates $q(t)$, generalized speeds $u(t)$, and auxiliary states $z(t)$, such as muscle activations. We may also seek time-invariant parameters $p$, the initial time of the motion $t_0$, or the final time of the motion $t_f$. We place lower ($L$) and upper ($U$) bounds on all variables, as well as bounds on the initial and final values of the states and controls; these bounds allow solving boundary value problems such as standing from a squat.

\ocp

The variables must obey the system's multibody dynamics (involving the mass matrix $M$; applied forces $f_\mathrm{app}$ from gravity, muscles, etc.; and centripetal and Coriolis terms $f_\mathrm{inertial}$) and any auxiliary dynamics, which may be expressed as explicit ($f_{\dot{z},\mathrm{ex}}$) or implicit ($f_{\dot{z},\mathrm{im}}$) differential equations. The system may contain position-level (holonomic) kinematic constraints to, for example, weld a foot to a bicycle pedal. Each constraint is enforced by forces exerted by tissue, bones, bodies, or other parts of the modeled system. These generalized constraint forces are applied in the constrained directions (e.g., the six degrees of freedom between the foot and pedal), and we introduce time-varying Lagrange multiplier variables $\lambda$ to solve for these forces. The derivative of the kinematic constraints $\phi$ yields the kinematic constraint Jacobian $G$; the transpose of this matrix converts the Lagrange multipliers into generalized forces along the system's degrees of freedom. See S1 Appendix for details on how Moco handles kinematic constraints.

Additionally, the variables must obey boundary constraints $V_k$ (with bounds $V_{L,k}$ and $V_{U,k}$) and algebraic path constraints $g$ over the motion (with time-invariant bounds $g_L$ and $g_U$). The cost terms and boundary constraints may depend on initial and final time; states; controls; kinematic constraint multipliers (required for joint reactions); time-invariant parameters; and an integral, $S_{c,j}$ or $S_{b,k}$, over the motion.

We demonstrate Moco's interface with a MATLAB example that seeks the force to apply to a point mass to move the mass by one meter (starting and ending at rest) in minimum time:
\begin{lstlisting}
study = MocoStudy();
problem = study.updProblem();
problem.addGoal(MocoFinalTimeGoal()); % minimum-time problem
problem.setModel(Model('sliding_mass.osim')); % load model from file
problem.setTimeBounds(0, [0, 5]); % initial time = 0, final time <= 5 s
problem.setStateInfo('/slider/position/value', [-5, 5], 0, 1); % move 1 m
problem.setStateInfo('/slider/position/speed', [-50, 50], 0, 0);
problem.setControlInfo('/actuator', [-50, 50]);
solution = study.solve();
\end{lstlisting}
Setting the model and adding a cost (termed ``goal'' in the example) each
require only a single statement. Setting bounds on states and controls by name is easier and less bug-prone than setting bounds by index, as is common in other direct collocation software.

Direct collocation relies on gradient-based optimization, and therefore converges faster and more reliably when all functions in the optimal control problem are continuous and differentiable. To this end, Moco includes a muscle model \textit{DeGrooteFregly2016Muscle}~\cite{Groote:2016dq} and a compliant contact force model \textit{SmoothSphereHalfSpaceForce}~\cite{Serrancoli:2019aa} that are continuous and differentiable.

Users wishing to employ a cost term, boundary constraint, or path constraint that Moco does not support can create a C++ plugin using the same steps as for OpenSim plugins. By providing a library of cost, boundary constraint, and path constraint modules, allowing users to create their own modules, and allowing these modules to be combined, we achieve our design goals of ease-of-use, customizability, and extensibility.


\subsection*{Solving problems with \textit{MocoSolver}}

All details of solving an optimal control problem are encapsulated in \textit{MocoSolver}, which is decoupled from \textit{MocoProblem} for flexibility. The \textit{MocoProblem} knows nothing about the solver that may be used. When a user defines a custom cost term, they need not worry about how the solver will handle the cost. The only assumption made by \textit{MocoSolver} about the problem is that it describes a multibody system; this allows using special solver algorithms not suited to generic dynamic systems, such as for handling kinematic constraints~\cite{Posa:2016}. Moco users can add bodies or muscles to their model without modifying the solver, a convenience often not afforded by custom research code that couples the problem formulation to the solver. \textit{MocoSolver} uses the CasADi library~\cite{Andersson:2019} to transcribe the continuous optimal control problem defined by \textit{MocoProblem} into a finite-dimensional nonlinear program, which we solve with well-established gradient-based nonlinear program solvers such as IPOPT~\cite{Wachter:2006} and SNOPT~\cite{Gill:2005} (see S1 Appendix).

Moco provides two transcription schemes: the second-order trapezoidal scheme and the third-order Hermite-Simpson scheme~\cite{Betts:2010}. Multibody dynamics can be expressed with either explicit differential equations (“forward dynamics”) or implicit differential equations (“inverse dynamics”); problems may converge faster in implicit mode~\cite{vandenBogert:2011fv,Groote:2016dq}. Solving a musculoskeletal optimal control problem often requires trying many problem formulations and solver settings. Moco users can change the transcription scheme, dynamics mode, and other solver settings with a single line of code.

Solving a \textit{MocoStudy} yields a \textit{MocoSolution} (Figure 2), which is a subclass of \textit{MocoTrajectory} and provides easy access to the values of all variables at any iteration in the optimization. Users provide initial guesses via \textit{MocoTrajectory}, and can use the solution from one problem as the initial guess for a subsequent problem; this permits users to build a complex study by solving a series of simpler studies. For example, a simulation to predict the change in walking kinematics due to an external perturbation (e.g., an ankle exoskeleton) could benefit from an initial guess generated from a series of tracking simulations where kinematic deviations from reference data are gradually penalized less in the objective. \textit{MocoSolution} provides additional information, including whether the solver converged, the final objective value, and the number of solver iterations.

% Place figure captions after the first paragraph in which they are cited.
\begin{figure}[!h]
    %\begin{adjustwidth}{-2.25in}{0in} % Comment out/remove adjustwidth environment if table fits in text column.
    \centering
    \includegraphics{../figures/MocoSolverDiagram.png}
    \caption{{\bf Using trajectories to solve problems iteratively.}
    Guesses for the optimization are specified using \textit{MocoTrajectory}, which holds the values of states, controls, Lagrange multipliers, and parameters at any iteration in the optimization. \textit{MocoSolution} is a subclass of \textit{MocoTrajectory} that holds the solution to a study and includes the success status of the optimization, the final objective value, and the number of solver iterations. Users can use the solution of one problem as the initial guess for a subsequent problem.
    }
    \label{mocosolverdiagram}
    %\end{adjustwidth}
\end{figure}

After solving a problem, users often wish to visualize the solution as an animation, plot the state and control trajectories, or compute quantities from the solution. With a \textit{MocoStudy} and \textit{MocoSolution}, each of these tasks require only a single line of code. \textit{MocoTrajectories} can be written to and read from tab-delimited \textit{Storage} text files, which are familiar to OpenSim users. The ability to save \textit{MocoTrajectories} and \textit{MocoStudies} to files allows users to reproduce each other's results, which is essential for sound science~\cite{Peng:2011}.

\subsection*{Tools for standard problems}

Currently, Moco provides two tools for solving standard problems (Figure 3):
\begin{itemize}
\item \textit{\textit{MocoInverse}} solves the muscle/actuator redundancy problem~\cite{Groote:2016dq}, wherein we solve for muscle (or other actuator) controls that achieve a motion that is prescribed exactly (see S1 Appendix) while minimizing effort or other costs.
\item \textit{\textit{MocoTrack}} solves motion tracking problems, wherein we solve for both a motion and muscle (or other actuator) controls that minimize the error with an observed motion in addition to effort or other costs.
\end{itemize}
\textit{MocoTrack} is useful for predicting deviations from motion data (e.g., predicting kinematic adaptations to an exoskeleton), while \textit{MocoInverse} is a faster option when the motion should be enforced exactly (e.g., estimating elastic energy storage for an observed motion). \textit{MocoTrack} can use contact models instead of applying measured external forces to the model, as would be done with \textit{MocoInverse}. Applying measured external forces often requires introducing non-physiological “residual” actuators to resolve inconsistencies between measured forces, measured kinematics, and mass properties. For both tools, the only required inputs are an OpenSim model and motion data (coordinate or marker trajectories, and external forces). Internally, the tools build a \textit{MocoStudy} with solver settings that yield fast and reliable convergence on problems we tested.

% Place figure captions after the first paragraph in which they are cited.
\begin{figure}[!h]
    %\begin{adjustwidth}{-2.25in}{0in} % Comment out/remove adjustwidth environment if table fits in text column.
    \centering
    \includegraphics{../figures/MocoToolDiagram.png}
    \caption{{\bf Solving prescribed motion, tracked motion, and predicted motion problems.}
Moco provides the tools \textit{MocoTrack} and \textit{MocoInverse} for solving standard problems. Both require a \textit{Model} and kinematic data as inputs and produce controls and actuator states as outputs, but these tools solve different optimal control problems. \textit{MocoTrack} produces a new simulated motion, while \textit{MocoInverse} does not permit deviations from the provided kinematic data. Predicting a motion is not easily standardized and requires using a custom \textit{MocoStudy}.    }
    \label{mocotooldiagram}
    %\end{adjustwidth}
\end{figure}

Future versions of Moco may include tools for model calibration, electromyography-driven simulation, and other standard problems. For problems that do not fit into a standard form, such as predicting a motion, using \textit{MocoStudy} provides the necessary flexibility.

\subsection*{Verification}

Verifying software is essential for good science and gaining the trust of users~\cite{Hicks:2015bo}; thus, we conducted extensive verification tests. For example, producing the known solution to an optimal control problem verifies that Moco implements direct collocation correctly. We solved the following linear optimal control problem, which has a known solution:

\analytic

Moco's solution for the optimal control matched the known control solution with a root-mean-square error of $8.0 \times 10^{-8}$.

Next, we ensured that a time-stepping forward simulation using controls from a motion prediction produced the same motion as in the prediction. These tests used a model consisting of a point mass suspended by three muscles (\textit{DeGrooteFregly2016Muscle}) and under the influence of gravity (Figure 4). For this problem, the muscles had activation dynamics and rigid tendons. We first predicted the state and control trajectories to move the point mass between prescribed initial and final positions, starting and ending at rest (Figure 4, gray band). In this prediction, the cost included both the sum of squared muscle excitations and the final time. Then, we used the predicted controls to perform a time-stepping forward simulation using an OpenSim integrator (Figure 4, blue line). The resulting position trajectory of the point mass matched that from the prediction with a root-mean-square error of 0.0051 m (1.7\% of the distance between the initial and final positions). This gives us confidence that Moco enforces the same multibody and muscle dynamics enforced in a time-stepping forward simulation in OpenSim. For more complex problems, conducting a time-stepping forward simulation using controls from a \textit{MocoSolution} requires a stabilizing feedback controller to counteract numerical errors.

% Place figure captions after the first paragraph in which they are cited.
\begin{figure}[!h]
%    \begin{adjustwidth}{-2.25in}{0in} % Comment out/remove adjustwidth environment if table fits in text column.
        \centering
        \includegraphics{../figures/suspended_mass.png}
        \caption{{\bf Verification of time-stepping and motion tracking.}
       The trajectory of a point mass suspended by three muscles and moving under the influence of gravity ($g$) in three different types of simulation is shown on the left. The activations of the “left,” “middle,” and “right” muscles throughout the motion are shown on the right. We predicted a trajectory (gray band) that minimized the sum of squared muscle excitations and final time. We then performed a time-stepping forward simulation (blue) with the predicted controls and produced the motion we originally predicted. Tracking the predicted motion with \textit{MocoTrack} (orange) produced the original activations.
        }
        \label{verification}
%    \end{adjustwidth}
\end{figure}

To gain confidence in motion tracking problems, we ensured that using \textit{MocoTrack} on a synthesized motion with known muscle activity produced the original muscle activity. We used the same suspended point mass model and tracked the previous motion prediction (Figure 4, gray band) while minimizing squared excitations. The muscle activations from \textit{MocoTrack} (Figure 4, orange line) matched those from the prediction with a root-mean-square error that was 0.23\% of the peak predicted activation. To show that there are indeed multiple muscle activity trajectories that produce the same motion, we tracked the motion while minimizing the sum of muscle excitations raised to the fourth power; this resulted in a much larger root-mean-square error that was 11\% of the peak predicted activation. For most tracking problems of interest, we do not know the true muscle activity solution; verifying tracking problems using synthesized data gives us confidence in Moco's estimates of muscle activity for real-world data.

Moco contains an automated test suite with over 30 files that extends beyond the verification described here. For example, the test suite ensures that users receive error messages for incorrect input, that a \textit{MocoStudy} can be written to and read from an XML file, that kinematic constraints are enforced, and that implicit and explicit differential equations lead to the same solution. We ensure all these tests succeed before accepting changes to the code.

\section*{Results}

\subsection*{Estimating muscle activity from motion capture data of walking}

Moco can estimate muscle activity in walking, which allows studies of gait disorders and muscle coordination. We used a model with 19 degrees of freedom and 80 lower-limb muscles~\cite{Rajagopal:2016ek} to simulate one gait cycle of walking at a self-selected speed of 1.25 m/s. The scaled model and data are based on the supplementary material of~\cite{Rajagopal:2016ek}. All muscles had activation dynamics but only the gastrocnemii and soleus had compliant tendons~\cite{Groote:2016dq}. We solved for muscle activity using \textit{MocoInverse}, which prescribes kinematics exactly (see “Tools for standard problems” for details), and compared the resulting muscle activations to electromyography measurements (Figure 5).

% Place figure captions after the first paragraph in which they are cited.
\begin{figure}[!h]
        \begin{adjustwidth}{-1.125in}{-1.125in} % Comment out/remove adjustwidth environment if table fits in text column.
    \centering
    \includegraphics{../figures/motion_tracking_walking.png}
    \caption{{\bf Estimates of muscle activity during walking.}
    \textit{MocoInverse} produced muscle activations (black) whose timing matched the timing from electromyography measurements (gray; available for all muscles shown except psoas)~\cite{Arnold:2013cs}. Electromyography was normalized such that its peak matched the peak of the \textit{MocoInverse} activations. Minimizing knee joint loading reduced the activity of the vastus lateralis, biceps femoris short head, and medial gastrocnemius, which span the knee (blue).
    }
    \label{walking}
        \end{adjustwidth}
\end{figure}
\textit{MocoInverse} produced activations that included some of the major features of the electromyography data~\cite{Arnold:2013cs}, such as the timing of peak activity for the semitendinosus, biceps femoris short head, vastus lateralis, medial gastrocnemius, and soleus. With \textit{MocoInverse}, the difference between required net joint moments and muscle-generated net joint moments (termed “reserve” moments in OpenSim) had a maximum value of 2.5 N-m across time and degrees of freedom~\cite{Hicks:2015bo}. \textit{MocoInverse} solved this problem in 4.4 minutes, using a 3.6 GHz Intel Core i7 processor with 8 parallel threads; this duration is similar to the amount of time required by the Computed Muscle Control~\cite{Thelen:2003bba} tool in OpenSim for solving prescribed motion problems~\cite{Rajagopal:2016ek}.

To demonstrate how Moco allows customization, we added a cost term to \textit{MocoInverse} to minimize knee joint loading. With this additional cost, the peak magnitude of the knee joint reaction force decreased from 4.7 to 2.9 body weights. As expected, the activity of muscles crossing the knee joint (vastus lateralis, biceps femoris short head, and medial gastrocnemius) decreased. To compensate for the reduced medial gastrocnemius moment at the ankle, soleus activity increased, as seen in a previous simulation study~\cite{DeMers:2014}. Activity of the semitendinosus increased to compensate for the decrease in activity of the biceps femoris short head. Psoas activity increased to its maximum value; while a subject attempting to minimize the same objective in an experiment may not maximally activate their psoas, this high activity was allowed by our problem definition. Joint loading is a more complex cost than simply minimizing excitations; the problem solved in 48 minutes.

\subsection*{Predicting and assisting a squat-to-stand motion}

To show that Moco can predict motions and optimize parameters of a model, we predicted a squat-to-stand motion that minimized a combination of effort, expressed as the sum of squared excitations, and the duration of the motion. The initial pose was prescribed to be squatting~\cite{Fregly:2015}, and the final pose was prescribed to be upright standing. No motion was tracked. The model contained a torso and leg with 9 muscles obeying activation dynamics and compliant tendon dynamics. To enforce mediolateral symmetry, we used a single leg and doubled muscle strengths, which we obtained from a previous study~\cite{Ong:2019}. We used Moco's default initial guess, in which each variable's value is the midpoint of the variable's bounds. The predicted motion and muscle activations are shown in Figure 6. As expected, extensor muscles such as the gluteus maximus, hamstrings, and vasti exhibited the greatest activity.

% Place figure captions after the first paragraph in which they are cited.
\begin{figure}[!h]
    \begin{adjustwidth}{-1.125in}{-1.125in} % Comment out/remove adjustwidth environment if table fits in text column.
        \centering
        \includegraphics{../figures/squat_to_stand.png}
        \caption{{\bf Predicting and assisting a squat-to-stand motion.}
We predicted a squat-to-stand motion with prescribed initial and final poses that minimized the sum of squared muscle excitations and final time (gray). The predicted motion is shown on the left, and the activations of key muscles are shown on the right. We then added a torsional spring to the knee and solved for the optimal motion, muscle activations, and spring stiffness $k$ (blue). The spring allowed gluteus maximus and vasti activity to decrease substantially.
        }
        \label{squattotstand}
    \end{adjustwidth}
\end{figure}

Next, we added a torsional spring to the knee and solved for the optimal motion, muscle activations, and spring stiffness. The spring was in equilibrium when the knee was extended, as illustrated in Figure 6. We used the same cost as in the unassisted case; no motion was tracked. With the assistive device, the motion was achieved with lower muscle activity. The optimal spring stiffness was 88 N-m/rad.

Both predictions solved in under 3 minutes. Moco's ability to rapidly predict motions and optimize device parameters makes it a valuable tool for designing assistive devices.


\section*{Availability and future directions}

OpenSim Moco can be downloaded freely for Windows and Mac from SimTK and GitHub (https://simtk.org/projects/opensim-moco and https://github.com/opensim-org/opensim-moco), where we develop the project and users can report bugs and request features. The OpenSim Moco source code is available under the permissive Apache License 2.0, though some dependencies have more restrictive licenses (e.g., CasADi~\cite{Andersson:2019} is available under the GNU Lesser General Public License).

The documentation for Moco contains a User Guide, Theory Guide, Developer Guide, and an Application Programming Interface (API) Reference. The User Guide explains how to use Moco and provides tips for posing a problem. The Theory Guide explains how Moco implements direct collocation, and the Developer Guide introduces the code and explains software design choices. The API Reference describes the classes and functions in the library. Lastly, we provide a printable two-page “cheat sheet” that demonstrates common commands in Moco.

The Moco distribution contains examples in MATLAB, Python, and C++. These examples range from predicting the optimal trajectory for a double pendulum to predicting 2-D muscle-driven walking (which solves in under an hour). The code used to generate the results for this paper are available at https://github.com/stanfordnmbl/mocopaper.

Moco currently lacks the ability to handle certain problems. Metabolic energy consumption is a commonly used cost term, but direct collocation struggles with the nonconvexity of many energy consumption models. Koelewijn et al. recently published a smoothed energy consumption model for use in direct collocation~\cite{Koelewijn:2019}; we hope Moco will include this model in the future. Implementing a cost term that minimizes the error between measured and simulated contact forces would improve the accuracy of simulated ground reaction forces in tracking problems. Many direct collocation formulations allow a problem to contain multiple phases, each with different system dynamics. Supporting multiple phases enables modeling foot–ground contact with kinematic constraints instead of compliant contact, which would avoid the poor numerical conditioning caused by the stiffness of compliant contact. Falisse et al. used a multiple-phase approach to solve for muscle parameters that fit multiple unrelated motions~\cite{Falisse:2016}. By including cost terms for energy expenditure and contact force tracking and permitting multiple phases, Moco could cover a wider range of biomechanics applications.

The performance and ease of use of Moco's direct collocation solvers could be improved. Supporting mesh refinement would allow the solver to increase the number of mesh intervals in time ranges with fast dynamics, thereby improving accuracy. Computing the nonlinear program derivatives with algorithmic differentiation instead of finite differences would vastly improve the speed of Moco, but would require substantial changes to the source code of OpenSim and its dependencies~\cite{Falisse:2019a}.

We designed Moco to be easy to use, customizable, and extensible. We verified the software and applied it to multiple musculoskeletal problems. Given this foundation, we expect Moco to accelerate research by reducing the time spent wrestling with simulation tools and enabling our field to tackle more ambitious problems. Moco handles models with kinematic constraints, muscle activation dynamics, compliant tendons, and compliant contact, and can minimize a combination of complex costs such as marker tracking and joint reaction loads. To build a community that sustains the Moco project, we have organized several in-person workshops. We invite the community to help improve the software and contribute documentation, examples, teaching materials, and code.

\section*{S1 Appendix}

\subsection*{Kinematic constraints}

Support for kinematic constraints is a key feature of Moco. Understanding how kinematic constraints are handled in multibody dynamics is valuable for understanding how Moco handles such problems. Consider a two-dimensional point mass system with coordinates $q_x$ and $q_y$ constrained to a parabola $0 = q_y - q_x^2$. To prevent the point mass from violating the constraint, we must apply a force perpendicular to the parabola. Each constraint has a corresponding scalar force variable, called a Lagrange multiplier $\lambda$. We must solve for the required magnitudes of these constraint forces, but the direction in which we apply each of these forces is determined by the derivative of the constraint equations. We gather the derivatives of the constraint equations in the kinematic constraint Jacobian matrix $G$. Each row in this matrix contains the derivative of a single constraint equation with respect to each degree of freedom, and the matrix has a column for each degree of freedom. For the parabola example, the Jacobian is $( -2q_x, 1)$. The transpose of this matrix, $G^T$, contains columns that are vectors in the state space which are perpendicular to each constraint. For our single constraint, the vector $(-2q_x, 1)^T$ is perpendicular to the parabola. The matrix-vector product between the Jacobian transpose and the Lagrange multipliers, $G^T \lambda$, yields the vector of generalized forces (whose length is the number of degrees of freedom) necessary for enforcing the system constraints. For our point mass example, the generalized forces yielded by the vector-scalar product  $(-2q_x, 1)^T \lambda$ keep the point mass on the parabola. To apply these forces to the multibody system, we include the $G^T \lambda$ term in the multibody dynamics equations of motion.

When simulating a multibody system with time-stepping forward integration, we first ensure the initial generalized coordinates and speeds satisfy the kinematic constraints $\phi(q) = 0$ and their first derivative $\dot{\phi}(q, u) = 0$ via a root-solve. During the integration, we solve for generalized accelerations and Lagrange multipliers that obey the multibody dynamics equations of motion and the second derivative of the kinematic constraints, $\ddot{\phi}(q, u, \dot{u}) = 0$. Numerically integrating the resulting generalized accelerations yields generalized coordinates and speeds that approximately lie on the constraint manifold defined by $\phi(q) = 0$; to fix any errors in the constraints caused by numerical integration error, we project the generalized coordinates and speeds back onto the constraint manifold~\cite{Sherman:2011byc}.

In direct collocation, the generalized coordinates, generalized speeds, and Lagrange multipliers are the unknowns—we are solving for the entire trajectory of the system. When expressing multibody dynamics as implicit differential equations, the generalized accelerations are also unknowns. How we solve for the trajectory of the system in the presence of kinematic constraints depends on the transcription scheme; see the remainder of this Appendix for details.

\subsection*{Defining problems containing prescribed kinematics}

A common task in musculoskeletal biomechanics is to estimate the muscle and actuator behavior that drove an observed motion. We can solve this problem by minimizing the error between the observed motion and the simulated motion, as with Computed Muscle Control (using the ``slow target'')~\cite{Thelen:2003bba} or \textit{MocoTrack}. Alternatively, we can prescribe the motion exactly, as with Static Optimization, electromyography-driven simulation~\cite{Lloyd:2003}, and the Muscle Redundancy Solver~\cite{Groote:2016dq}. Consider a two-dimensional point mass with coordinates $q_x$ and $q_y$ for which we prescribe a circular motion via the functions $\hat{q}_x(t) = \cos(t)$ and $\hat{q}_y(t) = \sin(t)$. We can either add these functions to the kinematic constraints $\phi(q)$, or we can substitute these functions into the equations of motion, thereby eliminating the variables $q_x$ and $q_y$. With Moco, users can choose either the former approach through OpenSim's \textit{Coordinate}, or the latter (and usually preferable) approach using \textit{PositionMotion}, a new component that employs Simbody's \textit{Motion} class. Prescribing kinematics by eliminating variables leads to a problem that is robust and fast---the nonlinear multibody dynamics are removed from the optimization problem---but prevents predicting kinematic deviations from the observed motion.

When we prescribe kinematics in Moco by eliminating variables, we replace the problem in Eq (1) with the following:

\prescribed

We replace the kinematic variables $q$ and $u$ with known quantities $\hat{q}$ and $\hat{u}$. The system still depends on auxiliary state variables $z$ and control variables $x$, and includes auxiliary dynamics. If none of the parameter variables affect the multibody system, then the multibody dynamics are reduced to a force balance: muscles and other force elements must generate the net generalized forces determined by the kinematics and external loads data. The easiest way to prescribe kinematics in Moco is to use the \textit{MocoInverse} tool.

Whether the motion is prescribed by adding constraints or eliminating variables, OpenSim supplements the modeled force elements with Lagrange multipliers to ensure the prescribed motion is achieved. When using \textit{PositionMotion} with Moco, we require that the prescribed motion's Lagrange multipliers are zero, thereby ensuring the motion is fully generated by the modeled force elements.

\subsection*{Transcription schemes}

\subsubsection*{Trapezoidal transcription}

The trapezoidal scheme transcribes the optimal control problem into a nonlinear program by approximating integrals using the trapezoidal rule. As a second-order scheme, trapezoidal transcription exhibits accuracy that improves four-fold when halving the mesh interval (i.e., time step).

We discretize the continuous variables $t$, $y$, $x$, and $\lambda$ on a mesh of time points $t_i$ defined by dimensionless time $\tau_i$, yielding $n$ mesh intervals with durations $h_i$:

\traptau

For conciseness, we define the following function:

\trapfunc

where $\mathrm{trap}_i()$ is a trapezoidal rule approximation of the area under the function $F$ for mesh interval $i$, and $\eta$ represents any subset of continuous variables. We define the explicit multibody dynamics function as:

\explicitmultibody

The mass matrix $M$, the centripetal and Coriolis forces $f_\mathrm{inertial}$, and kinematic constraint Jacobian $G$ are computed by Simbody (OpenSim's multibody dynamics engine) using order-N recursive algorithms; the complete mass matrix is not computed explicitly. The applied forces $f_\mathrm{app}$ are usually defined by OpenSim components that implement Simbody force elements. Simbody computes the constraint Jacobian $G$ based on any Simbody kinematic constraints that the OpenSim model adds to the system. In Moco, the Lagrange multipliers $\lambda$ are explicit optimization variables; this approach differs from that in forward simulations, in which Simbody solves for accelerations and multipliers simultaneously.

The result of the trapezoidal transcription, with multibody dynamics expressed as explicit differential equations, is the following nonlinear program:

\trapnlp

In this form, the problem can be solved directly by a nonlinear program solver. We introduce the algebraic (control) variable $\zeta$ as the derivative of auxiliary state variables whose dynamics are expressed with an implicit differential equation.

When expressing the multibody dynamics implicitly, we remove the constraint involving $f_{\dot{u}}$, introduce generalized accelerations as an algebraic variable $\upsilon$, and enforce multibody dynamics in “inverse dynamics” form:

\trapimplicit

The constant $\upsilon_B$ is a large positive number (1000 by default).

The dynamic, kinematic, and path constraints are enforced at a set of discrete time points, so the quadratic spline approximation to the continuous variables may violate the original continuous-time constraints between the discrete time points. For this reason, a mesh with more points leads to a more accurate solution.

Our implementation of trapezoidal transcription handles kinematic constraints, but not in the most robust fashion. We enforce $\phi$ but not its time derivatives; enforcing the constraints at only the position level yields an index-3 differential-algebraic system of equations, which is challenging to solve~\cite{Hairer:1996,Campbell:2016,Betts:2010}. Furthermore, we minimize these multipliers (with weight $w_\lambda$) to improve numerical conditioning.

When kinematics are prescribed (see “Prescribed kinematics”), multibody dynamics must be expressed implicitly and kinematic constraints are not enforced; we expect the prescribed kinematics to already obey the constraints.

\subsubsection*{Hermite-Simpson transcription}

The Hermite-Simpson scheme transcribes the optimal control problem into a nonlinear program by approximating integrals using a Hermite interpolant and Simpson integration rule. As a third-order scheme, Hermite-Simpson transcription exhibits accuracy that improves eight-fold when halving the mesh interval.

We use a similar dimensionless time mesh as for the trapezoidal scheme, with $n$ mesh intervals with durations $h_i$. We also introduce collocation points at the midpoints of the mesh intervals, leading to a total of $2n + 1$ time points at which we discretize the continuous variables:

\hermitesimpsontau

where $ \bar{\tau}_i $ denote mesh interval midpoints. For conciseness, we define the following functions:

\hermitesimpsonfuncs

where $\mathrm{hermite}_i()$ represents the Hermite interpolant and $\mathrm{simpson}_i()$ represents the Simpson integration rule. Again, $F$ is a function for mesh interval $i$, and $\eta$ represents any subset of continuous variables.

Using the explicit multibody dynamics function $f_{\dot{u}}$ defined previously, Hermite-Simpson transcription results in the following nonlinear program:

\hermitesimpsonnlp


The $G(\bar{q}_i, p)^T \bar{\gamma}_i$ term is a velocity correction that is necessary when enforcing derivatives of kinematic constraints in the nonlinear program. The additional variables $\bar{\gamma}_i$ prevent the kinematics from being overconstrained, and the kinematic constraint Jacobian transpose operator $G(\bar{q}_i, p)^T$ restricts the velocity correction to the tangent plane of the constraint manifold~\cite{Posa:2016}. Currently, we only support enforcing derivatives of position-level, or holonomic, constraints, represented by the equations:

\hermitesimpsonkincon

The explicit multibody dynamics function is used here where $\dot{u}$ would appear if it were a continuous variable in the problem (as in implicit mode, see below).

Algebraic constraints are not enforced at the midpoints of the mesh intervals, but exhibit fourth-order accuracy at these points~\cite{Posa:2016}.

For implicit multibody dynamics, we again remove the constraints involving $f_{\dot{u}}$ and introduce generalized accelerations as algebraic variables $\upsilon$ to enforce multibody dynamics in “inverse dynamics” form:

\hermitesimpsonimplicit

\subsection*{Moco's direct collocation solvers}

Moco provides two solvers as subclasses of \textit{MocoSolver}: \textit{MocoCasADiSolver} uses the third-party CasADi library~\cite{Andersson:2019}, and \textit{MocoTropterSolver} uses a direct collocation solver we developed named Tropter. CasADi is an open-source package for algorithmic differentiation and is a bridge to nonlinear program solvers IPOPT~\cite{Wachter:2006}, SNOPT~\cite{Gill:2005}, and others.

Gradient-based nonlinear program solvers require the gradient of the objective, the Jacobian of the constraints, and sometimes the Hessian of the Lagrangian~\cite{Betts:2010}. To maximize computational efficiency, these derivatives are ideally computed exactly through either analytic expressions or algorithmic differentiation~\cite{Andersson:2019,Walther:2003}. OpenSim's main distribution does not provide exact derivatives, so we use finite differences. CasADi is an ideal library for employing direct collocation, but two limitations led us to create Tropter: CasADi did not initially support finite differences, and CasADi's open-source license is more restrictive than OpenSim's. More recent versions of CasADi support finite differences and CasADi understands the structure of the nonlinear program objective and constraint functions, allowing for potentially more efficient finite difference calculations than with Tropter, which treats the nonlinear program objective and constraints as black-box functions~\cite{Patterson:2012}. If OpenSim provides exact derivatives in the future, we can exploit the algorithmic differentiation modes in Tropter and CasADi~\cite{Falisse:2019a}. Those distributing Moco as a dependency of closed-source software may prefer distributing Moco without CasADi, as CasADi's ``weak copyleft'' GNU Lesser General Public License 3.0 places requirements on how CasADi is redistributed.


\section*{Acknowledgments}

We thank Ajay Seth, Michael Sherman, Friedl de Groote, Michael Posa, Joris Gillis, and Joel Andersson for discussing methodology and implementation; Bradley Humphreys, Carmichael Ong, Noah Gordon, and Jenny Yong for contributing code; Andrew Baines, Mohammad Shourijeh, and Prasanna Sritharan for testing the software; and Ayman Habib for reviewing the manuscript.
This work was supported by the National Institutes of Health grants U54 EB020405 and P2C HD065690. CLD and NAB received support from the National Science Foundation Graduate Research Fellowship Program. CLD received support from the Stanford Bio-X Graduate Fellowship. NAB received support from the Stanford Graduate Fellowship Program.


\nolinenumbers

% Either type in your references using
% \begin{thebibliography}{}
% \bibitem{}
% Text
% \end{thebibliography}
%
% or
%
% Compile your BiBTeX database using our plos2015.bst
% style file and paste the contents of your .bbl file
% here. See http://journals.plos.org/plosone/s/latex for
% step-by-step instructions.
%

\bibliography{MocoPaper.bib}

%\begin{thebibliography}{10}
%
%\bibitem{bib1}
%Conant GC, Wolfe KH.
%\newblock {{T}urning a hobby into a job: how duplicated genes find new
%  functions}.
%\newblock Nat Rev Genet. 2008 Dec;9(12):938--950.
%
%\bibitem{bib2}
%Ohno S.
%\newblock Evolution by gene duplication.
%\newblock London: George Alien \& Unwin Ltd. Berlin, Heidelberg and New York:
%  Springer-Verlag.; 1970.
%
%\bibitem{bib3}
%Magwire MM, Bayer F, Webster CL, Cao C, Jiggins FM.
%\newblock {{S}uccessive increases in the resistance of {D}rosophila to viral
%  infection through a transposon insertion followed by a {D}uplication}.
%\newblock PLoS Genet. 2011 Oct;7(10):e1002337.
%
%\end{thebibliography}



\end{document}


